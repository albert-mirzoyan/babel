import crypto from 'node/crypto';
import Emitter from 'asx/runtime/events';
import Utils from 'asx/runtime/utils';

export class WebSocket {
    static MAP = {}
    static GUID="258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
    static guid(cid){
       return crypto.createHash('sha1')
        .update(cid+WebSocket.GUID,'ascii')
        .digest('base64');
    }
    static READY_STATE = {
        CONNECTING: 0,
        OPEN: 1,
        CLOSING: 2,
        CLOSED: 3
    }
    static OPCODE = {
        CONTINUE    : 0x00,
        TEXT        : 0x01,
        BINARY      : 0x02,
        CLOSE       : 0x08,
        PING        : 0x09,
        PONG        : 0x0A
    }

    static create(name){
        var Handler = WebSocket.get(name)
        if(Handler){
            return new Handler();
        }else{
            return false;
        }
    }
    static get(name){
        if(WebSocket.MAP[name]){
            return WebSocket.MAP[name];
        }else{
            return WebSocket.MAP[Utils.hypenize(name)]
        }
    }
    static
    constructor(child){
        if(child!=this){
            var id = child.constructor.id || Utils.hypenize(child.name)
            WebSocket.MAP[id]=child.constructor;
        }
    }
    constructor() {
        Emitter.inject(this);
        this._partialFrame = null;
        this._partialMessage = null;
        this._partialMessageIsText = null;
        this._buffer = new Buffer(0);
        this._bufferOffset = 0;
        this._bufferEnd = 0;
        this.heartbeatTimeout = 0;
        this._heartbeatTimeoutId = null;
        this.maskData = false;
        this.requireMaskedData = false;
        this.frameMaxLength = 1048576;
        this.messageMaxLength = 1048576;
        this.pingMaxLength = 1024;
        this.isBrowser = false;
        this.readyState = WebSocket.READY_STATE.CONNECTING;
        this.socket = null;
    }
    accept(server,request,arguments){
        var headers=request.headers;

        var upgrade     = headers['upgrade'].toLowerCase();
        var origin      = headers['origin'].toLowerCase();
        var protocols   = headers['sec-websocket-protocol'];
        var version     = headers['sec-websocket-version'];
        var cuid        = headers['sec-websocket-key'];
        var guid        = WebSocket.guid(cuid);

        if (!upgrade || upgrade != 'websocket') {
            // We can only upgrade to websocket connections.
            return request.reject('400 Bad Request');
        }
        if (version != '13') {
            // We can only upgrade to websocket connections.
            return request.reject('400 Unsuported Socket Version');
        }
        if (server.origin && (!origin && (
            origin != 'ws://' + server.origin ||
            origin != 'http://' + server.origin
        ))){
            return request.reject('403 Forbidden');
        }
        if(protocols){
            protocols = protocols.split(',').map(p=>p.trim());
            this.protocol = protocols.shift();
        }
        this.uid = guid;
        this.uri = request.url;
        this.arguments = arguments;
        this.headers = request.headers;
        this.server = server;
        this.requireMaskedData = server.requireMaskedData;
        if(this.authorize()){
            request.accept('101 Switching Protocols',{
                'Connection'                : 'Upgrade',
                'Upgrade'                   : 'websocket',
                'Sec-WebSocket-Accept'      : this.uid,
                'Sec-WebSocket-Protocol'    : this.protocol
            })
            this.setHeartbeatTimeout(server.heartbeat);
            this._open(request.socket);
            return true;
        }else{
            return request.reject('401 Unauthorized');
        }
    }
    authorize(){
        return true;
    }
    connect(options, callback) {
        options = options || {};

        // Prepare the options that will be given to the new HttpServer.
        var serverHost = options.host || 'localhost';
        var serverPort = options.port || 80;

        // Remove any options specific for the HttpServer, since the rest of the
        // values will be used to overwrite values in the WebSocket.
        delete options.host;
        delete options.port;

        // Create the WebSocket that will recieve all events; and that will
        // eventually be assigned the socket generated by the HTTP request below.
        var webSocket = new WebSocket();

        // Copy any value from the options object to the newly created WebSocket.
        for (value in options) {
            if (webSocket.hasOwnProperty(value))
                webSocket[value] = options[value];
        }

        if (callback)
            webSocket.on('open', callback);

        // The security key should be 16 bytes long and base 64 encoded. The data
        // should be random.
        var randomBuf = crypto.randomBytes(16);
        var secKey = randomBuf.toString('base64');

        // The client should then response with the following value.
        var sha1 = crypto.createHash('sha1');
        sha1.update(secKey + WEBSOCKET_GUID, 'ascii');
        var secAccept = sha1.digest('base64');

        var reqOptions = {
            host: serverHost,
            port: serverPort,
            headers: {
                'Upgrade': 'websocket',
                'Connection': 'Upgrade',
                'Sec-WebSocket-Version': '13',
                'Sec-WebSocket-Key': secKey
            }
        };
        if (options.origin) {
            reqOptions.headers.Origin = options.origin;
        }
        var req = http.request(reqOptions, function (res) {
            // This event should not fire if the host is a WebSocket server.
            try {
                throw new WebSocketError('Incorrect HTTP status code: ' + res.statusCode);
            } catch (ex) {
                webSocket._onError(ex);
            }
        });

        req.on('upgrade', function (res, socket, head) {
            // The response should look something like this
            //
            // HTTP/1.1 101 Switching Protocols
            // Upgrade: websocket
            // Connection: Upgrade
            // Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
            //
            try {
                if (!res.headers['upgrade'] || res.headers['upgrade'].toLowerCase() != 'websocket')
                    Error.toss('Incorrect upgrade-value: ' + res.headers['upgrade']);
                if (res.headers['sec-websocket-accept'] != secAccept)
                    Error.toss('Incorrect security key response.');
                // Our request was accepted! The socket have now been upgraded to a
                // web socket.
                webSocket._open(socket);
            } catch (ex) {
                webSocket._onError(ex);
            }
        });

        req.on('error', function (ex) {
            webSocket._onError(ex);
        });

        req.end('');

        return webSocket;
    }
    _open(socket) {
        try {
            if (!socket){
                Error.toss('Socket undefined.');
            }
            if (this.socket){
                Error.toss('Socket already assigned.');
            }
            if (this.readyState != WebSocket.READY_STATE.CONNECTING){
                Error.toss('Socket not connecting.');
            }
            this.socket = socket;
            this.socket.on('close', this._onClose.bind(this));
            this.socket.on('end', this._onEnd.bind(this));
            this.socket.on('error', this._onError.bind(this));
            this.socket.on('data', this._onData.bind(this));
            this.readyState = WebSocket.READY_STATE.OPEN;
            this.onOpen();
        } catch (ex) {
            console.info(ex.stack)
            this._onError(ex);
        }
    }
    onOpen(){
        this.emit('open');
    }
    onClose(){
        this.emit('close');
    }
    onError(ex){
        this.emit('error', ex);
    }
    onMessage(data,isBinary){
        this.emit('message', data, isBinary);
    }
    close() {
        if (this.readyState != WebSocket.READY_STATE.OPEN)
            return;
        this.readyState = WebSocket.READY_STATE.CLOSING;
        try {
            this._send(WebSocket.OPCODE.CLOSE, new Buffer(0));
        } catch (ex) {
        }
        this.socket.destroy();
    }
    _onClose() {
        if (this.readyState == WebSocket.READY_STATE.CLOSED)
            return;

        this.readyState = WebSocket.READY_STATE.CLOSED;

        // Cleanup.
        if (this._heartbeatTimeoutId != null)
            clearTimeout(this._heartbeatTimeoutId);

        this._buffer = null;
        this._partialFrame = null;
        this._partialMessage = null;

        this.onClose()
    }
    _onEnd() {
        // Do not allow any more I/O on the socket.
        this.socket.destroy();
        this._onClose();
    }
    _onError(ex) {
        this.close();
        this.onError(ex);
    }
    _sendHeartbeat() {
        this._send(WebSocket.OPCODE.PONG, new Buffer(0));
    }
    _onData(data) {
        if (this.readyState == WebSocket.READY_STATE.CONNECTING)
            return; // Protocol not yet negotiated.
        if (this.heartbeatTimeout > 0)
            this._resetHeartbeatTimeout();
        try {
            // When recieving data, we might recieve 2 bytes or 65 kB, we never
            // know what to expect. Thus, we must ensure there is enough data to
            // parse a frame's header before trying, and we must also ensure that
            // the entire frame's payload have been downloaded before throwing a
            // message event.
            // Append the new data to the buffer.
            var lengthOfAllData = this._bufferEnd + data.length;
            if (lengthOfAllData > this._buffer.length - this._bufferEnd) {
                // The current buffer is too small to hold all the data; enlarge it
                // and add all the new and old data.
                var buffer = new Buffer(lengthOfAllData);
                this._buffer.copy(buffer, 0, 0, this._bufferEnd);
                data.copy(buffer, this._bufferEnd);

                this._buffer = buffer;
            } else {
                // The current buffer can hold all of the recieved data.
                data.copy(this._buffer, this._bufferEnd);
            }
            this._bufferEnd = lengthOfAllData;
            // Try to parse a frame from the downloaded data.
            this._parseFrame();
        } catch (ex) {
            this._onError(ex);
        }
    }
    _parseFrame() {
        if (this._partialFrame) {
            // A partially downloaded frame already exists. The new downloaded data
            // might contain some more payload and/or another frame.
            this._parseFramePayload();
            return;
        }

        // According to the WebSocket protocol data is sent in frames as the one
        // described below.
        //
        // http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5
        //
        //   0               1               2               3
        //   0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
        //  +-+-+-+-+-------+-+-------------+-------------------------------+
        //  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
        //  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
        //  |N|V|V|V|       |S|             |   (if payload len==126/127)   |
        //  | |1|2|3|       |K|             |                               |
        //  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
        //  |     Extended payload length continued, if payload len == 127  |
        //  + - - - - - - - - - - - - - - - +-------------------------------+
        //  |                               |Masking-key, if MASK set to 1  |
        //  +-------------------------------+-------------------------------+
        //  | Masking-key (continued)       |          Payload Data         |
        //  +-------------------------------- - - - - - - - - - - - - - - - +
        //  :                     Payload Data continued ...                :
        //  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        //  |                     Payload Data continued ...                |
        //  +---------------------------------------------------------------+

        // Keep track of the buffer offset, localy, since it might not be stored.
        var offset = this._bufferOffset;

        // Make sure there is enough data to read the beginning of the header.
        if (this._bufferEnd - offset < 2)
            return;

        var frame = {
            isFinal        : false,
            opcode         : -1,
            isMasked       : false,
            length         : 0,
            maskingKey     : null,
            payload        : null,
            payloadStart   : 0,
            frameStart     : 0
        };
        frame.frameStart = offset;

        // Read the two bytes required to parse the header.
        var byte0 = this._buffer[offset++];
        var byte1 = this._buffer[offset++];

        frame.isFinal = (byte0 & 0x80) > 0;
        frame.opcode = byte0 & 0x0F;
        frame.isMasked = (byte1 & 0x80) > 0;
        frame.length = byte1 & 0x7F;

        if (this.requireMaskedData && !frame.isMasked) {
            Error.toss('Unmasked data recieved while is required to be masked.');
        }

        // Make sure there is enough data to read the rest of the header.
        var requiredData = 0;
        if (frame.length == 126)
            requiredData += 2;
        if (frame.length == 127)
            requiredData += 8;
        if (frame.isMasked)
            requiredData += 4;

        if (this._bufferEnd - offset < requiredData) {
            // There is currently not enough data in the buffer to parse the rest of
            // the frame.
            return;
        }

        // Was the payload's length extended?
        if (frame.length == 126) {
            // Payload length extended to two bytes.
            frame.length = this._buffer.readUInt16BE(offset);
            offset += 2;
        } else if (frame.length == 127) {
            // Payload length extended to eight bytes. We can not read the last
            // four...
            offset += 4;
            frame.length = this._buffer.readUInt32BE(offset);
            offset += 4;

            if (frame.length >= 4294967295) {
                Error.toss('Too much data.');
            }
        }

        if (this.frameMaxLength > 0 && frame.length > this.frameMaxLength) {
            Error.toss('WebSocketFrame payload exceeds maximum allowed length.');
        }

        // Read masking key, if any.
        if (frame.isMasked) {
            frame.maskingKey = [
                this._buffer[offset++],
                this._buffer[offset++],
                this._buffer[offset++],
                this._buffer[offset++]
            ];
        }

        // Keep track of where the frame's data starts in the buffer.
        frame.payloadStart = offset;

        this._partialFrame = frame;
        this._bufferOffset = offset;

        this._parseFramePayload();
    }
    _parseFramePayload() {
        if (!this._partialFrame)
            Error.toss('Unable to parse payload since no partial frame exists.');

        var frame = this._partialFrame;

        if (this._bufferEnd - frame.payloadStart < frame.length) {
            // The buffer does not yet contain the entire payload.
            return;
        }

        if (frame.isMasked) {
            // Demask the payload data.
            for (var i = frame.length - 1; i >= 0; i--)
                this._buffer[i + frame.payloadStart] = this._buffer[i + frame.payloadStart] ^ frame.maskingKey[i % 4];
        }

        // Store the frame's payload.
        var payloadEnd = frame.payloadStart + frame.length;
        frame.payload = this._buffer.slice(frame.payloadStart, payloadEnd);

        // Remove the frame from the buffer and do some cleanup.
        this._buffer = this._buffer.slice(payloadEnd);
        this._bufferEnd = this._buffer.length;
        this._bufferOffset = 0;
        this._partialFrame = null;

        // WebSocketFrame decoded and ready.
        this._handleFrame(frame);

        if (this._bufferEnd > 0) {
            // There is still some data in the buffer; it might contain another
            // frame...
            this._parseFrame();
        }
    }
    _handleFrame(frame) {
        try {
            switch (frame.opcode) {
                case WebSocket.OPCODE.BINARY:
                    // Binary data recieved. It might be fragmented.
                    if (frame.isFinal) {
                        // Message is not fragmented.
                        this.onMessage(frame.payload,true);
                        return;
                    }

                    // Message is fragmented and this is the message's first frame.
                    if (this._partialMessage)
                        Error.toss('Fragmented message recieved but there is already a partial message in the buffer.');

                    this._partialMessage = frame.payload;
                    this._partialMessageIsText = false;
                    return;

                case WebSocket.OPCODE.TEXT:
                    // Text data recieved, encoded as UTF8. It might be fragmented.
                    if (frame.isFinal) {
                        // Message is not fragmented.
                        var data = frame.payload.toString('utf8');
                        this.onMessage(data,false);
                        return;
                    }

                    // Message is fragmented and this is the message's first frame.
                    if (this._partialMessage)
                        Error.toss('Fragmented message recieved but there is already a partial message in the buffer.');

                    this._partialMessage = frame.payload;
                    this._partialMessageIsText = true;
                    return;

                case WebSocket.OPCODE.CONTINUE:
                    // Fragmented message recieved. There should already be a
                    // partial message in the ._partialMessage buffer.
                    if (!this._partialMessage)
                        Error.toss('CONTINUE frame recieved but no partial message was present in the buffer.');

                    // Append the partial message to the buffer. If this is not the
                    // final frame, more data will be appended to the buffer when
                    // the next frame is recieved.

                    // Calculate the length of the new buffer and make sure it does
                    // not exceed the maximum allowed length.
                    var newLength = this._partialMessage.length + frame.length;

                    if (this.messageMaxLength > 0 && newLength > this.messageMaxLength)
                        Error.toss('Message exceeds maximum allowed length.');

                    // Create the new buffer and copy the old data and append the
                    // new.
                    var buffer = new Buffer(newLength);
                    this._partialMessage.copy(buffer);
                    frame.payload.copy(buffer, this._partialMessage.lenght);
                    this._partialMessage = buffer;

                    if (frame.isFinal) {
                        // This was the final frame -- the entire message have been
                        // recieved.
                        var data = this._partialMessage;

                        var isText = this._partialMessageIsText;
                        if (isText)
                            data = data.toString('utf8');

                        // Clean up.
                        this._partialMessage = null;
                        this._partialMessageIsText = null;
                        this.onMessage(data,!isText);
                    }
                    return;

                case WebSocket.OPCODE.CLOSE:
                    // Client says it is time to close the connection. We must obay.
                    this.close();
                    return;

                case WebSocket.OPCODE.PING:
                    // PING frames are sent as keep-alive, heartbeat etc. Any data
                    // found should be returned.
                    if (this.pingMaxLength > 0 && frame.length > this.pingMaxLength) {
                        // Only reply to a PING if the sent data does not exceed the
                        // maximum allowed length. This is a try to avoid ping of
                        // death.
                        Error.toss('Maximum PING data length exceeded.');
                        return;
                    }

                    this._send(WebSocket.OPCODE.PONG, frame.payload);
                    return;

                case WebSocket.OPCODE.PONG:
                    // Unsolicited PONG frame -- a response is not expected. This
                    // serves as a unidirectional heartbeat.
                    return;

                default:
                    Error.toss('Unsupported OP code: ' + frame.opcode);
            }
        } catch (ex) {
            this._onError(ex);
        }
    }
    _send(opcode, payload) {
        if (this.readyState != WebSocket.READY_STATE.OPEN)
            return;

        // TODO: Rewrite the send code to not buffer the data twice. Instead small
        // amounts of data can be sent each time instead (this will thus affect the
        // payload buffer if masking is enabled).

        if (this.heartbeatTimeout > 0)
            this._resetHeartbeatTimeout();

        try {
            // In order to send data, it must be encoded in a frame similar to the one
            // used when data is recieved.
            //
            // http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17
            //
            //   0               1               2               3
            //   0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
            //  +-+-+-+-+-------+-+-------------+-------------------------------+
            //  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
            //  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
            //  |N|V|V|V|       |S|             |   (if payload len==126/127)   |
            //  | |1|2|3|       |K|             |                               |
            //  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
            //  |     Extended payload length continued, if payload len == 127  |
            //  + - - - - - - - - - - - - - - - +-------------------------------+
            //  |                               |Masking-key, if MASK set to 1  |
            //  +-------------------------------+-------------------------------+
            //  | Masking-key (continued)       |          Payload Data         |
            //  +-------------------------------- - - - - - - - - - - - - - - - +
            //  :                     Payload Data continued ...                :
            //  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
            //  |                     Payload Data continued ...                |
            //  +---------------------------------------------------------------+
            //

            var payloadLength = payload.length;

            // Total length of frame.
            var length = payloadLength + 2;

            // Do we need to extend the payload length field?
            if (payloadLength >= 126)
                length += 2;
            if (payloadLength >= 65536)
                length += 6;
            if (this.maskData)
                length += 4;

            // Keep track of the current frame buffer offset.
            var offset = 0;

            // Create the buffer that will hold the entier frame.
            var frameBuffer = new Buffer(length);
            frameBuffer[offset++] = 0x80 + (opcode & 0x0F); // FIN = 1, WebSocket.OPCODE = opcode

            // Append the payload length...
            if (payloadLength < 126) {
                frameBuffer[offset++] = payloadLength;
            } else if (payloadLength < 65536) {
                // Payload length extended to two bytes.
                frameBuffer[offset++] = 126;
                frameBuffer.writeUInt16BE(payloadLength, offset);
                offset += 2;
            } else {
                // Payload length extended to eight bytes.
                if (payloadLength > 4294967295) {
                    // For now, only data lengths that can fit into a 32-bit
                    // unsigned integer are allowed.
                    Error.toss('WebSocketFrame payload length not suppored.');
                }

                frameBuffer[offset++] = 127;
                frameBuffer.writeUInt32BE(0, offset);
                offset += 4;
                frameBuffer.writeUInt32BE(payloadLength, offset);
                offset += 4;
            }

            if (this.maskData)
                offset += 4;

            // Copy the payload to the frame. This will allow a single .write() to
            // be made on the socket.
            payload.copy(frameBuffer, offset);

            if (this.maskData) {
                // Mask the payload in the frame buffer.
                frameBuffer[1] |= 0x80;

                var maskKey = crypto.randomBytes(4);
                maskKey.copy(frameBuffer, offset - 4);

                for (var i = payload.length - 1; i >= 0; i--)
                    frameBuffer[i + offset] = frameBuffer[i + offset] ^ maskKey[i % 4];
            }

            // The frame is now ready to be sent to the client!
            this.socket.write(frameBuffer);
        } catch (ex) {
            this._onError(ex);
        }
    }
    send(payload) {
        if (this.readyState != WebSocket.READY_STATE.OPEN){
            return;
        }
        if (typeof payload == 'string') {
            this._send(WebSocket.OPCODE.TEXT, new Buffer(payload, 'utf8'));
        } else {
            this._send(WebSocket.OPCODE.BINARY, payload);
        }
    }
    setHeartbeatTimeout(timeout) {
        if (timeout < 0) {
            timeout = 0;
        }
        this.heartbeatTimeout = timeout;
        if (this._heartbeatTimeoutId != null) {
            clearTimeout(this._heartbeatTimeoutId);
        }
        if (timeout > 0) {
            this._heartbeatTimeoutId = setTimeout(this._sendHeartbeat.bind(this), timeout);
        } else {
            this._heartbeatTimeoutId = null;
        }
    }
    _resetHeartbeatTimeout() {
        if (this._heartbeatTimeoutId != null)
            clearTimeout(this._heartbeatTimeoutId);

        this._heartbeatTimeoutId = setTimeout(this._sendHeartbeat.bind(this), this.heartbeatTimeout);
    }
}
export default WebSocket;